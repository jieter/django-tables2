import itertools
from django.conf import settings
from django.test.client import RequestFactory
from django.template import Template, Context
import django_tables as tables
from django_attest import TransactionTestContext
from attest import Tests, Assert
from .testapp.models import Person, Occupation


models = Tests()
models.context(TransactionTestContext())


class PersonTable(tables.Table):
    first_name = tables.Column()
    last_name = tables.Column()
    occupation = tables.Column()


@models.test
def boundrows_iteration():
    occupation = Occupation.objects.create(name='Programmer')
    Person.objects.create(first_name='Bradley', last_name='Ayers', occupation=occupation)
    Person.objects.create(first_name='Chris',   last_name='Doble', occupation=occupation)

    table = PersonTable(Person.objects.all())
    records = [row.record for row in table.rows]
    expecteds = Person.objects.all()
    for expected, actual in itertools.izip(expecteds, records):
        Assert(expected) == actual


@models.test
def verbose_name():
    """
    When using queryset data as input for a table, default to using model field
    verbose names rather than an autogenerated string based on the column name.

    However if a column does explicitly describe a verbose name, it should be
    used.
    """
    class PersonTable(tables.Table):
        """
        The test_colX columns are to test that the accessor is used to
        determine the field on the model, rather than the column name.
        """
        first_name = tables.Column()
        fn1 = tables.Column(accessor='first_name')
        fn2 = tables.Column(accessor='first_name.upper')
        fn3 = tables.Column(accessor='last_name', verbose_name='OVERRIDE')
        last_name = tables.Column()
        ln1 = tables.Column(accessor='last_name')
        ln2 = tables.Column(accessor='last_name.upper')
        ln3 = tables.Column(accessor='last_name', verbose_name='OVERRIDE')
        region = tables.Column(accessor='occupation.region.name')
        r1 = tables.Column(accessor='occupation.region.name')
        r2 = tables.Column(accessor='occupation.region.name.upper')
        r3 = tables.Column(accessor='occupation.region.name', verbose_name='OVERRIDE')

    # The Person model has a ``first_name`` and ``last_name`` field, but only
    # the ``last_name`` field has an explicit ``verbose_name`` set. This means
    # that we should expect that the two columns that use the ``last_name``
    # field should both use the model's ``last_name`` field's ``verbose_name``,
    # however both fields that use the ``first_name`` field should just use a
    # capitalized version of the column name as the column header.
    table = PersonTable(Person.objects.all())
    # Should be generated (capitalized column name)
    Assert('First name') == table.columns['first_name'].verbose_name
    Assert('First name') == table.columns['fn1'].verbose_name
    Assert('First name') == table.columns['fn2'].verbose_name
    Assert('OVERRIDE') == table.columns['fn3'].verbose_name
    # Should use the model field's verbose_name
    Assert('Surname') == table.columns['last_name'].verbose_name
    Assert('Surname') == table.columns['ln1'].verbose_name
    Assert('Surname') == table.columns['ln2'].verbose_name
    Assert('OVERRIDE') == table.columns['ln3'].verbose_name
    Assert('Name') == table.columns['region'].verbose_name
    Assert('Name') == table.columns['r1'].verbose_name
    Assert('Name') == table.columns['r2'].verbose_name
    Assert('OVERRIDE') == table.columns['r3'].verbose_name

@models.test
def column_mapped_to_nonexistant_field():
    """
    Issue #9 describes how if a Table has a column that has an accessor that
    targets a non-existent field, a FieldDoesNotExist error is raised.
    """
    class FaultyPersonTable(PersonTable):
        missing = tables.Column()

    table = FaultyPersonTable(Person.objects.all())
    table.as_html()  # the bug would cause this to raise FieldDoesNotExist
